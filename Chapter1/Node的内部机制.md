# Node的内部机制

程序由CPU执行，而在完成任务之前，CPU不会暂停或停止，它的运行和同步、异步或者阻塞、非租塞没有必然的联系。操作系统保证CPU始终处于运行状态，是通过调度来实现的，具体一点就是在不同的进程/线程间来回切换。

## 回调

回调就是通过函数参数的参数传递到其他代码的，某段可执行代码的引用。通俗的讲，就是将一个函数作为参数传递给另一个函数，并且作为参数的函数可被执行，它本质上是一个高阶函数。

> 高阶函数的概念：接受一个或多个函数作为参数输入，且会输出一个函数。

单线程的程序在运行时需要考虑这样的问题：如果遇到一个耗时操作，要不要等待操作完成后再进行下一步?

`Node` 没有选择这样方式，而是通过异步+回调的方式进行处理。当 `Node` 遇到耗时操作，比如IO操作时，会发起一个调用后继续向下执行，当IO操作完成后，再执行对应的回调函数(异步).

```js
var fs = require('fs');
var callback = function (err, data) {
  if (err) return;
  console.log(data.toString());
}
fs.readFile('foo.txt', callback);
```

## 同步/异步和阻塞/非阻塞

同步/异步描述的是进程/线程的调用方式。

同步指的是进程/线程发起调用后，会一直等待调用返回后才继续往下执行，这段时间，CPU会通过系统调度去另外的进程/线程执行任务，而后再回到现有的进程/线程上来。

而异步则是进程/线程发起调用后，不等待继续往下执行，当调用完成后，获取通知再回过头来执行。

阻塞和非阻塞是针对IO而言的，它关注程序在等待IO调用返回这段时间的状态。

## 单线程和多线程

`Java`、`C++`等高级语言都有多线程的语言特性，而 `Node` 没有提供多线程支持，我们的代码只能在单线程中运行。

而 `Node` 的底层并非是单线程的。`Libuv` 是 `Node` 的底层实现，它就有线程池的概念。

`Libuv` 是一个跨平台的异步IO库，专为 `Node` 提供了多平台下的异步IO支持，本身由 `C/C++` 实现，`Node` 的非阻塞IO以及事件循环都是由它来完成并实现的。

## 并行和并发

并行和并发是两个完全不同的概念。

打个比方，并发好比两队人取票，但只有一个取票机，A队第一个取完，就由B队的第一个来取。而并行则是两队人取票，但有两个取票机，各自队的人使用各自对应的取票机。

`Node` 通过异步+事件驱动的单线程特性来实现高并发，异步使得代码在面临多个请求时不会发生阻塞，事件驱动提供了IO调用后执行回调函数的能力。
